var SketchLib = {
  // Adds a new layer as a child of `container` with the given type
  // Valid types are 'group', 'text', 'image' and 'rectangle'
  // parameters is an optional dictionary containing zero or more of the
  // following keys:
  //  name (a string)
  //  rect (an NSRect)
  //  color (an MSColor)
  // returns the newly created layer
  "addLayer": function (container, type, parameters) {
    var layer = container.addLayerOfType(type);
    if (typeof(parameters.name) !== 'undefined') layer.name = parameters.name;
    if (typeof(parameters.rect) !== 'undefined') layer.rect = parameters.rect;
    if (typeof(parameters.color) !== 'undefined') {
      this.util.setFillColor(layer, parameters.color);
    } 
    return layer;
  },
  // Adds a new group (MSLayerGroup) as a child of `container`
  // See `addLayer` for a discussion of `parameters`
  // returns the newly created group
  "addLayerGroup": function (container, parameters) {
    return this.addLayer(container, "group", parameters);
  },
  // Adds a new text layer (MSTextLayer) as a child of `container`
  // In addition to the keys described in `addLayer`, `parameters` may also
  // contain the following keys:
  //  text (a string)
  //  fontSize (a number)
  // returns the newly created text layer
  "addTextLayer": function (container, parameters) {
    var textLayer = this.addLayer(container, "text", parameters);
    if (typeof(parameters.text) !== 'undefined') {
      textLayer.stringValue = parameters.text;
      if (typeof(parameters.name) == 'undefined') {
        textLayer.name = parameters.text;
      }
    }
    if (typeof(parameters.fontSize) !== 'undefined') textLayer.fontSize = parameters.fontSize;
    textLayer.adjustFrameToFit();
    return textLayer;
  },
  // Adds a new bitmap layer (MSBitmapLayer) as a child of `container`
  // In addition to the keys described in `addLayer`, `parameters` may also
  // contain the following keys:
  //  imageData (MSImageData)
  //  image (NSImage)
  //  url (NSURL)
  // returns the newly created bitmap layer
  "addImageLayer": function (container, parameters) {
    var imageLayer = this.addLayer(container, "image", parameters);
    var imageData = parameters.imageData;
    var image = null;

    if (typeof(imageData) === 'undefined') {
      var image = parameters.image;
      if (typeof(image) !== 'undefined') {
        imageData = this.util.imageDataFromImage(container, image);
      } else {
        var url = parameters.url;
        if (typeof(url) !== 'undefined' && url !== null) {
          imageData = this.util.imageDataFromURL(container, url);
        }
        if (typeof(imageData) !== 'undefined') {
          image = imageData.image();
        }
      }
    }

    if (typeof(image) !== 'undefined' && image !== null) {
      var originalImageSize = [image size];
      var fill = [[[imageLayer style] fills] addNewStylePart];
      [fill setIsEnabled:false];
      [imageLayer setConstrainProportions:false];
      [imageLayer setImage:[MSImageProxy proxyWithImageData:imageData]];
      var rect = CGRectZero;
      rect.size = originalImageSize;
      [imageLayer setRect:rect];
      [imageLayer setConstrainProportions:true];
    }
    return imageLayer;
  },
  // Adds a new shape group (MSShapeGroup) as a child of `container`
  // containing a rectangle path
  // See `addLayer` for a discussion of `parameters`
  // returns the newly created shape group
  "addShapeLayer": function (container, parameters) {
    return this.addLayer(container, "rectangle", parameters);
  },
  "util": {
    // Returns an MSImageData object for `image` (NSImage)
    "imageDataFromImage": function(container, image) {
      var imageCollection = [[container documentData] images];
      return [imageCollection addNSImage:image convertColourspace:false];
    },

    // Returns an MSImageData object for `url` (NSURL)
    "imageDataFromURL": function(container, url) {
      var image = [[NSImage alloc] initWithContentsOfURL:url];
      var imageData = undefined;
      if (typeof(image) !== 'undefined') {
        imageData = this.imageDataFromImage(container, image);
      }
      return imageData;
    },

    // Centers `layer` at `point`. If point is not specified `layer`
    // is centered at the origin (0,0)
    "centerLayer": function(layer, point) {
      var center = (typeof(point) !== 'undefined') ? point : CGPointMake(0,0);
      var rect = [layer rect];
      rect.origin.x = center.x-(CGRectGetWidth(rect)/2.0);
      rect.origin.y = center.y-(CGRectGetHeight(rect)/2.0);
      [layer setRect:rect];
    },
    
    // Sets the fill color for `layer` to `color` (MSColor)
    "setFillColor": function(layer, color) {
      var fill = [[[layer style] fills] addNewStylePart];
      [fill setColor: color];
    }
  }
};

/**
 * @param {NSMutableArray} array
 * @param {Number} atIndex
 * @param {Number} toIndex
 * @returns {NSMutableArray}
 */

function moveObject(array, atIndex, toIndex) {
  if (atIndex != toIndex) {
    var object = [[[array objectAtIndex:atIndex] retain] autorelease]

    [array removeObjectAtIndex:atIndex]
    [array insertObject:object atIndex:toIndex]
  }

  return array
}



/**
 * Sets `isSelected` to `true` for all given layers
 * @param {NSArray.<MSShapeGroup>} layers
 */

function restoreSelection(layers) {
  var loop = [layers objectEnumerator]

  while (layer = [loop nextObject]) {
    [layer setIsSelected:true]
  }
}



/**
 * Makes `NSApp sendAction` for `layer` `times` times
 * @param {NSDictionary} context
 * @param {String} action
 * @param {MSShapeGroup} layer
 * @param {Number} times
 */

function sendActionTimes(context, action, object, times) {
  var doc = context.document

  [[doc currentPage] deselectAllLayers]
  [object setIsSelected:true]

  for (var i = 0; i < times; i++) {
    [NSApp sendAction:action to:nil from:doc]
  }

  restoreSelection(context.selection)
}



/**
 * Returns layers sorted by first number in name
 * @param {NSArray.<MSShapeGroup>} layers
 * @returns {NSArray.<MSShapeGroup>}
 */

function sortLayers(layers, isAscending) {
  var sortDescriptor = [NSSortDescriptor sortDescriptorWithKey:'name'
                                         ascending:isAscending
                                         selector:'localizedStandardCompare:']

  return [layers sortedArrayUsingDescriptors:[sortDescriptor]]
}



/**
 * @typedef {Object} StepsStruct
 * @property {MSShapeGroup} layer
 * @property {Number} steps
 */

/**
 * Returns the quantity of steps that needed to reorder `layers`
 * in according to order of `sortedLayers`
 * @param {NSArray.<MSShapeGroup>} selection
 * @param {NSArray.<MSShapeGroup>} sortedLayers
 * @returns {Array.<StepsStruct>}
 */

function getSteps(selection, sortedLayers) {
  var steps = []
  var selectedLayers = [selection mutableCopy]

  for (var i = 0; i < [sortedLayers count]; i++) {
    var layer = [sortedLayers objectAtIndex:i]
    var index = [selectedLayers indexOfObject:layer]

    steps.push({ layer: layer, steps: index - i })

    selectedLayers = moveObject(selectedLayers, index, i)
  }

  return steps
}



/**
 * @param {NSArray.<MSShapeGroup>} selection
 * @returns {String}
 */

function getObjectName(selection) {
  var object = [selection firstObject]

  switch ([object class]) {
    case [MSShapeGroup class]:
      return 'layers'
    case [MSArtboardGroup class]:
      return 'artboards'
    default:
      return 'objects'
  }
}
